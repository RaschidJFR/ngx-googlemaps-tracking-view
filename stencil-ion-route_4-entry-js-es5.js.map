{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;AACA;AAAA;;AACQ,iEAAgB,IAAhB,EAAgBA,OAAhB;AACR;AACA;AACA;AACA;AACA;AACA;;AACA;AACA,qCAAmC,uDAAW,IAAX,EAAW,qBAAX,EAAW,CAAX,CAAnC;AACA;;AAXA;AAAA;AAAA,iBAYA;AACA;AACA;AAdA;AAAA;AAAA,iBAeA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;;AATA,uDAUAC,KAVA;AAAA;;AAAA;AAUA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAfA;AAAA;AAAA;AAAA;AAAA;AAgBA;AA/BA;AAAA;AAAA,iBAgCA;AACA;AACA;AAlCA;AAAA;AAAA,eAmCA;AAA4B;AAC5B,iCAD4B;AAE5B,uCAF4B;AAG5B;AAH4B;AAI5B;AAvCA;;AAAA;AAAA;;AA0CA;AACA;AAAA;;AACQ,iEAAgB,IAAhB,EAAgBD,OAAhB;AACR,yCAAuC,uDAAW,IAAX,EAAW,yBAAX,EAAW,CAAX,CAAvC;AACA;;AAJA;AAAA;AAAA,iBAKA;AACA;AACA;AAPA;AAAA;AAAA,iBAQA;AACA;AACA;AAVA;AAAA;AAAA,eAWA;AAA4B;AAC5B,uCAD4B;AAE5B;AAF4B;AAG5B;AAdA;;AAAA;AAAA;;AAiBA;AACA;AACA;;AAEA;AACA,4BACAE,MADA,CACA;AAAA;AAAA,SADA,EAEAC,IAFA,CAEA,GAFA;AAGA;AACA,OALA;;AAMA;AACA;;AADA,oDAEAC,KAFA;AAAA;;AAAA;AAEA;AAAA;;AAAA,wDACAC,UADA;AAAA;;AAAA;AACA;AAAA;;AACA;AACA;;AACA;AACA;AACA;;AACAC;AACA,iBANA,MAOA;AACAA;AACA;AACA;AAZA;AAAA;AAAA;AAAA;AAAA;AAaA;AAfA;AAAA;AAAA;AAAA;AAAA;;AAgBA;AACA,OAjBA;;AAkBA;AACA,4DACAC,eADA,sBAEAD,IAFA;;AAIA;AACAE;AACA;;AACA;AACAC;AACA,SAFA,MAGA;AACAA;AACA;AACA,OAdA;;AAeA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA,wBAAoBC,iBAApB,EAAuCA,GAAvC,EAAuC;AACvC;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA,OAhBA;;AAiBA;AACA;;AACA;AACA;AACAC,uCACAC,aADA,GAEA,EAFA;AAGA;;AACA;AACA;AACA;AACA,OAXA;;AAYA;AACA;AACA;AACA;;AACA,uCACAC,GADA,CACA;AAAA;AAAA,SADA,EAEAX,MAFA,CAEA;AAAA;AAAA,SAFA;;AAGA;AACA;AACA,SAFA,MAGA;AACA;AACA;AACA,OAbA;;AAeA;AACAY,kDAAuCC,aAAvC;;AADA,oDAEAA,MAFA;AAAA;;AAAA;AAAA;AAAA,gBAEAX,KAFA;AAGA;AACAA;AAAA;AAAA;AACA;AAAA;AAAA;AACAU,uCAA4BE,kBAA5B,GAA+C,uCAA/C,EAAsE,MAAtE,aAAuGC,cAAvG;AANA;;AAEA;AAAA;AAKA;AAPA;AAAA;AAAA;AAAA;AAAA;;AAQAH;AACA,OATA;;AAUA;AACAA,qDAA0CI,gBAA1C;;AADA,oDAEAA,SAFA;AAAA;;AAAA;AAEA;AAAA;;AACA;AACAJ,mDAA0CE,2BAA1C,GAAsE,mBAAtE,EAAsE,OAAtE,eAA6GA,yBAA7G,GAAuI,mBAAvI;AACA;AACA;AANA;AAAA;AAAA;AAAA;AAAA;;AAOAF;AACA,OARA;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAAK;AAAA;AAEA;AACAC,wBAHA,GAGAC,mBAHA,EAIA;;AAJA,wBAKAC,gCALA;AAAA;AAAA;AAAA;;AAAA,mDAMAH,OANA;;AAAA;AAAA;AAAA,yBAQAC,yBARA;;AAAA;AASAf,uBATA,GASAD,YATA;AAAA;AAAA,yBAUAgB,oDAVA;;AAAA;AAUAG,wBAVA;;AAWA;AACA;AACA;AACAC;AACAL;AACA,mBAhBA,CAiBA;;;AAjBA;AAAA,yBAkBAM,oEAlBA;;AAAA;AAkBAN,yBAlBA;;AAAA,uBAqBAI,kBArBA;AAAA;AAAA;AAAA;;AAAA;AAAA,yBAsBAA,oBAtBA;;AAAA;AAAA,mDAwBAJ,OAxBA;;AAAA;AAAA;AAAA;AA2BAL;AA3BA,mDA4BA,KA5BA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AA+BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACAG,qBADA,GACA,EADA;AAGAS,sBAHA,GAGAC,IAHA,EAIA;;AAJA;AAAA,uBAKA,IALA;AAAA;AAAA;AAAA;;AAMAP;;AANA,uBAOAA,MAPA;AAAA;AAAA;AAAA;;AAAA;AAAA,yBAQAA,mBARA;;AAAA;AAQAQ,oBARA;;AAAA,uBASAA,EATA;AAAA;AAAA;AAAA;;AAUAF;AACAE;AACAX;AAZA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA,oDAsBA;AAAaA,4BAAb;AAAaG;AAAb,mBAtBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAwBA;AACA;AACA;AACA;;AACA;AACAS;AAA6DC;AAA7D;AACK,SAFL;AAGA,OAPA;;AAQA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA,OATA;;AAWA;AACA,YAAYC,IAAZ,GAAuB1B,KAAvB,CAAY0B,IAAZ;AAAA,YAAYC,EAAZ,GAAuB3B,KAAvB,CAAY2B,EAAZ;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA,wBAAoBtB,eAApB,EAAqCA,GAArC,EAAqC;AACrC;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA,OAlBA;;AAmBA;AACA;AAAA;AAAA;AACA,OAFA;;AAGA;AACA;AACA;;AACA,eAAWA,OAAX,EAAoBA,GAApB,EAAoB;AACpB;AACA;AACA;AACA;;AACA;AACA,OATA;;AAUA;AACA;AACA;AACA;;AACA,wBAAoBA,gBAApB,EAAsCA,GAAtC,EAAsC;AACtC;;AACA;AACAuB;AACA,WAFA,MAGA;AAAA,wDACA3B,IADA;AAAA;;AAAA;AACA;AAAA;AACA,2CADA,CAEA;;AACA;AACA;AACA;AACA;;AACA4B;AACA;AACAC;AACA,iBAPA,MAQA;AACA;AACA;AACA;AAfA;AAAA;AAAA;AAAA;AAAA;;AAgBAF;AACA;AACA;;AACA,uCACAA,2CADA,GAEA,IAFA;;AAGA;AACA;AACA;;AACA;AACA;AAAA;AACAL,0BADA;AAEAtB,8BAFA;AAGA6B;AAHA;AAAA;AAKA;;AACA;AACA,OA1CA;;AA2CA;AACA;AACA;AACA,SAFA,MAGA;AACA;AACA,SAFA,MAGA;AACA,iDAA6CC,CAA7C,GAA6CC,CAA7C;AACA;;AACA;AACA,OAXA;;AAYA;AACA;AACA;AACA;AAAA;AAAA;;AAHA,oDAIAC,MAJA;AAAA;;AAAA;AAIA;AAAA;AACA;;AACA;AACAC;AACAC;AACA;AACA;AAVA;AAAA;AAAA;AAAA;AAAA;;AAWA;AACA;AAAA;AACAZ,0BADA;AAEAtB,8BAFA;AAGA6B;AAHA;AAAA;AAKA;;AACA;AACA,OAnBA;;AAoBA;AACA;AACA;;AAFA,oDAGAG,MAHA;AAAA;;AAAA;AAGA;AAAA;AACA;;AACA;AACA;;AACA;AACAG;AACAF;AACA;AACA;AACA;AAZA;AAAA;AAAA;AAAA;AAAA;;AAaA;AACA,OAdA;;AAeA;AACA;AACA;;AAFA,oDAGAnC,KAHA;AAAA;;AAAA;AAGA;AAAA;;AAAA,yDACAC,UADA;AAAA;;AAAA;AACA;AAAA;;AACA;AACAqC;AACA,iBAFA,MAGA;AACAA;AACA;;AACAC;AACA;AATA;AAAA;AAAA;AAAA;AAAA;AAUA;AAbA;AAAA;AAAA;AAAA;AAAA;;AAcA;AACA,OAfA;;UAgBAC;AACA;AAAA;;AACA;AACA;;;;iBACA;AACA;AACA;AACA;;AACA;AACA;;;;;;AAGA;AACA,yCACA1C,MADA,CACA;AAAA;AAAA,SADA,EAEAW,GAFA,CAEA;AACA;AACA;AACAkB,iDADA;AAEAC;AAFA;AAIK,SARL;AASA,OAVA;;AAWA;AACA;AACA,OAFA;;AAGA;AAAA;AACA,yCACA9B,MADA,CACA;AAAA;AAAA,SADA,EAEAW,GAFA,CAEA;AACA;;AACA;AACA;AACA;;AACA;AACAP,gDADA;AAEAsB,uCAFA;AAGAO,qCAHA;AAIAU;AAJA;AAMK,SAbL;AAcA,OAfA;;AAgBA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA,OARA;;AASA;AACA;;AADA,qDAEAC,KAFA;AAAA;;AAAA;AAEA;AAAA;AACAC;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;;AAKA;AACA,OANA;;AAOA;AACA;AACAC;AACApB,qBADA;AAEAtB,yBAFA;AAGA6B;AAHA;;AAKA;AACApB;AACA;AACA;;AAVA,qDAWAW,aAXA;AAAA;;AAAA;AAWA;AAAA;AACAqB;AACA;AAbA;AAAA;AAAA;AAAA;AAAA;AAcA,OAdA;;AAgBA;AACA;AAAA;;AACQ,iEAAgB,IAAhB,EAAgB/C,OAAhB;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA,oCAAkC,uDAAW,IAAX,EAAW,oBAAX,EAAW,CAAX,CAAlC;AACA,mCAAiC,uDAAW,IAAX,EAAW,mBAAX,EAAW,CAAX,CAAjC;AACA;;AA9BA;AAAA;AAAA;AAAA,6FA+BA;AAAA;AAAA;AAAA;AAAA;AACAc;AADA;AAAA,6BAEAmC,kBAFA;;AAAA;AAGAnC;AAHA;AAAA,6BAIA,sBAJA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aA/BA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,iBAqCA;AACAe,+DAA2D,yDAAQ,iCAAR,EAAQ,EAAR,CAA3D;AACAA,2DAAuD,yDAAQ,+BAAR,EAAQ,GAAR,CAAvD;AACA;AAxCA;AAAA;AAAA,iBAyCA;AACA;AACA;AACAf;AACA;AACA;AA9CA;AAAA;AAAA,iBA+CA;AAAA;;AACAoC;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvDA;AAAA;AAAA,iBAwDA;AAAA;;AACA;AACA1C;AACA;;AACAM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAnEA;AAAA;AAAA,iBAoEA;AACAe;AACA;AACA;AACA;;AAxEA;AAAA;AAAA;AAAA,sFAyEA;AAAA;AAAA;AAAA;AAAA;AACAf;AACAA;AACAqC;AACAC;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAzEA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AA+EA;;AA/EA;AAAA;AAAA;AAAA,sFAgFA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,2BACA,SADA;AAAA;AAAA;AAAA;;AAEAtC;AAFA,wDAGA,KAHA;;AAAA;AAAA;AAAA,6BAK8BuC,kCAL9B;;AAAA;AAAA;AAKgBpC,yBALhB,uBAKgBA,GALhB;AAKgBG,4BALhB,uBAKgBA,MALhB;AAMAL,4BANA,GAMAuC,mBANA;AAOAlD,2BAPA,GAOAmD,6BAPA;;AAAA,0BAQAnD,KARA;AAAA;AAAA;AAAA;;AASAU;AAAA;AAAA;AATA,wDAUA,KAVA;;AAAA;AAYAR,0BAZA,GAYAkD,kBAZA;;AAAA,0BAaAlD,IAbA;AAAA;AAAA;AAAA;;AAcAQ;AAdA,wDAeA,KAfA;;AAAA;AAiBAA;AACA;AAlBA;AAAA,6BAmBA,iFAnBA;;AAAA;AAAA,wDAoBA,IApBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAhFA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,iBAsGA;AACA;;AACA;AACA;AACA;AACA;AA3GA;AAAA;AAAA,iBA4GA;AACA;AACA;AA9GA;AAAA;AAAA,iBA+GA;AACA;;AACA;AACA;AACA2C;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA,aAFA,MAGA;AACA;AACA,aAFA,MAGA;AACA;AACA;AACA;AAjIA;AAAA;AAAA;AAAA,6FAkIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0BACAnD,IADA;AAAA;AAAA;AAAA;;AAEAQ;AAFA,wDAGA,KAHA;;AAAA;AAKA;AACAI,+BANA,GAMAwC,sBANA;AAOAC,8BAPA,GAOAC,8BAPA;AAQAC,kCARA,GAQA,IARA;;AASA;AACA;AACAA;AACAvD;AACA,uBAbA,CAcA;;;AACAS,4BAfA,GAeAuC,mBAfA;AAgBAlD,2BAhBA,GAgBA0D,+BAhBA;;AAAA,0BAiBA1D,KAjBA;AAAA;AAAA;AAAA;;AAkBAU;AAlBA,wDAmBA,KAnBA;;AAAA;AAAA,wDAsBA,2EAtBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAlIA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6FA0JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAAQ;AAAA;AAAA,6BACA,WADA;;AAAA;AACAyC,4BADA;AAEA5C,6BAFA,GAEA,KAFA;AAAA;AAAA;AAAA,6BAIA,qEAJA;;AAAA;AAIAA,6BAJA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAOAL;;AAPA;AASAiD;AATA,wDAUA5C,OAVA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aA1JA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gFAsKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA6C,uBADA,GACA,gBADA;AAGA;AAAA;AAAA;;AAHA,4BAIAA,eAJA;AAAA;AAAA;AAAA;;AAAA;AAAA,6BAKAA,CALA;;AAAA;AAAA,wDAOAC,OAPA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAtKA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,0FA+KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA3C;;AAAA,2BACA,SADA;AAAA;AAAA;AAAA;;AAEAR;AAFA,wDAGA,KAHA;;AAAA;AAKA,uCALA,CAMA;;AACAoD,gCAPA,GAOA,yCAPA;;AAQA;AACA;AACA;;AAVA;AAAA,6BAWAzC,6CAXA;;AAAA;AAWAN,6BAXA;AAYA;;AACA;AACAL;AACA,uBAfA,CAgBA;;;AACA;AACA;AACA;;AAnBA,wDAoBAK,OApBA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aA/KA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,iBAqMA;AACA;AACAgD;AACA;AAxMA;AAAA;AAAA,iBAyMA;AACA;AACA;AA3MA;AAAA;AAAA,iBA4MA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACApC,wBADA;AAEAqC,4CAFA;AAGApC;AAHA;AAKA;AAzNA;AAAA;AAAA,eA0NA;AAAe,mBAAO,uDAAU,IAAV,CAAP;AAAiB;AA1NhC;;AAAA;AAAA;;AA6NA;;AAEA;AACA;AAAA;;AAAA;;AACQ,iEAAgB,IAAhB,EAAgBhC,OAAhB;AACR;AACA;AACA;AACA;;AACA;;AACA;AACY,mEAAO,WAAP,EAAOkD,EAAP,EAAO,sBAAP;AACZ,WAFA;AAGA;;AAXA;AAAA;AAAA,iBAYA;AAAA;;AACA,uBAAqB,8DAAU,IAAV,CAArB;AACA;AACAmB,6BADA;AAEAC,2BAFA;AAGAC;AAHA;AAKA,mBAAgB,uDAAEC,iDAAF,EAAM;AAAIC,mCAAJ;AAAI,uDAA8D,uDAAkB,UAAlB,CAA9D,yDAAiGC,IAAjG,EAAiG,IAAjG,mCAAiG,iBAAjG,EAAiG,IAAjG;AAAJ,aAAN,EAAuJ,uDAAC,GAAD,EAACC,kBAAsBC,KAAtB,CAAD,EAAiC,uDAAC,MAAD,EAAC,IAAD,CAAjC,CAAvJ,CAAhB;AACA;AApBA;;AAAA;AAAA;;AAsBAC;;;","names":["hostRef","keys1","filter","join","chain","route","path","parsePath","url","history","i","pathname","hash","map","console","routes","generatePath","ids","redirects","changed","outlet","searchNavNode","index","result","direction","writeNavState","node","root","id","window","once","from","to","matchesDefault","allparams","params","a","b","chains","match","maxMatches","matches","score","level","RouterSegments","children","nodes","flattenNode","s","waitUntilNavNode","ev","printRoutes","printRedirects","readNavState","readRoutes","routerIDsToChain","chainToPath","win","readRedirects","redirect","routeRedirect","redirectFrom","routerPathToChain","unlock","p","resolve","routeEvent","writePath","redirectedFrom","href","rel","target","_index_2cd7e630_js__WEBPACK_IMPORTED_MODULE_0__","onClick","mode","Object","attrs","RouterLink"],"sources":["webpack:///node_modules/@ionic/core/dist/esm/ion-route_4.entry.js"],"sourcesContent":["import { r as registerInstance, d as createEvent, e as getElement, h, H as Host } from './index-2cd7e630.js';\nimport { b as getIonMode } from './ionic-global-a175fa73.js';\nimport { e as debounce } from './helpers-d8b49b57.js';\nimport { o as openURL, c as createColorClasses } from './theme-c2dc54d9.js';\n\nconst Route = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        /**\n         * Relative path that needs to match in order for this route to apply.\n         *\n         * Accepts paths similar to expressjs so that you can define parameters\n         * in the url /foo/:bar where bar would be available in incoming props.\n         */\n        this.url = '';\n        this.ionRouteDataChanged = createEvent(this, \"ionRouteDataChanged\", 7);\n    }\n    onUpdate(newValue) {\n        this.ionRouteDataChanged.emit(newValue);\n    }\n    onComponentProps(newValue, oldValue) {\n        if (newValue === oldValue) {\n            return;\n        }\n        const keys1 = newValue ? Object.keys(newValue) : [];\n        const keys2 = oldValue ? Object.keys(oldValue) : [];\n        if (keys1.length !== keys2.length) {\n            this.onUpdate(newValue);\n            return;\n        }\n        for (const key of keys1) {\n            if (newValue[key] !== oldValue[key]) {\n                this.onUpdate(newValue);\n                return;\n            }\n        }\n    }\n    connectedCallback() {\n        this.ionRouteDataChanged.emit();\n    }\n    static get watchers() { return {\n        \"url\": [\"onUpdate\"],\n        \"component\": [\"onUpdate\"],\n        \"componentProps\": [\"onComponentProps\"]\n    }; }\n};\n\nconst RouteRedirect = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.ionRouteRedirectChanged = createEvent(this, \"ionRouteRedirectChanged\", 7);\n    }\n    propDidChange() {\n        this.ionRouteRedirectChanged.emit();\n    }\n    connectedCallback() {\n        this.ionRouteRedirectChanged.emit();\n    }\n    static get watchers() { return {\n        \"from\": [\"propDidChange\"],\n        \"to\": [\"propDidChange\"]\n    }; }\n};\n\nconst ROUTER_INTENT_NONE = 'root';\nconst ROUTER_INTENT_FORWARD = 'forward';\nconst ROUTER_INTENT_BACK = 'back';\n\nconst generatePath = (segments) => {\n    const path = segments\n        .filter(s => s.length > 0)\n        .join('/');\n    return '/' + path;\n};\nconst chainToPath = (chain) => {\n    const path = [];\n    for (const route of chain) {\n        for (const segment of route.path) {\n            if (segment[0] === ':') {\n                const param = route.params && route.params[segment.slice(1)];\n                if (!param) {\n                    return null;\n                }\n                path.push(param);\n            }\n            else if (segment !== '') {\n                path.push(segment);\n            }\n        }\n    }\n    return path;\n};\nconst writePath = (history, root, useHash, path, direction, state) => {\n    let url = generatePath([\n        ...parsePath(root),\n        ...path\n    ]);\n    if (useHash) {\n        url = '#' + url;\n    }\n    if (direction === ROUTER_INTENT_FORWARD) {\n        history.pushState(state, '', url);\n    }\n    else {\n        history.replaceState(state, '', url);\n    }\n};\nconst removePrefix = (prefix, path) => {\n    if (prefix.length > path.length) {\n        return null;\n    }\n    if (prefix.length <= 1 && prefix[0] === '') {\n        return path;\n    }\n    for (let i = 0; i < prefix.length; i++) {\n        if (prefix[i].length > 0 && prefix[i] !== path[i]) {\n            return null;\n        }\n    }\n    if (path.length === prefix.length) {\n        return [''];\n    }\n    return path.slice(prefix.length);\n};\nconst readPath = (loc, root, useHash) => {\n    let pathname = loc.pathname;\n    if (useHash) {\n        const hash = loc.hash;\n        pathname = (hash[0] === '#')\n            ? hash.slice(1)\n            : '';\n    }\n    const prefix = parsePath(root);\n    const path = parsePath(pathname);\n    return removePrefix(prefix, path);\n};\nconst parsePath = (path) => {\n    if (path == null) {\n        return [''];\n    }\n    const segments = path.split('/')\n        .map(s => s.trim())\n        .filter(s => s.length > 0);\n    if (segments.length === 0) {\n        return [''];\n    }\n    else {\n        return segments;\n    }\n};\n\nconst printRoutes = (routes) => {\n    console.group(`[ion-core] ROUTES[${routes.length}]`);\n    for (const chain of routes) {\n        const path = [];\n        chain.forEach(r => path.push(...r.path));\n        const ids = chain.map(r => r.id);\n        console.debug(`%c ${generatePath(path)}`, 'font-weight: bold; padding-left: 20px', '=>\\t', `(${ids.join(', ')})`);\n    }\n    console.groupEnd();\n};\nconst printRedirects = (redirects) => {\n    console.group(`[ion-core] REDIRECTS[${redirects.length}]`);\n    for (const redirect of redirects) {\n        if (redirect.to) {\n            console.debug('FROM: ', `$c ${generatePath(redirect.from)}`, 'font-weight: bold', ' TO: ', `$c ${generatePath(redirect.to)}`, 'font-weight: bold');\n        }\n    }\n    console.groupEnd();\n};\n\nconst writeNavState = async (root, chain, direction, index, changed = false) => {\n    try {\n        // find next navigation outlet in the DOM\n        const outlet = searchNavNode(root);\n        // make sure we can continue interacting the DOM, otherwise abort\n        if (index >= chain.length || !outlet) {\n            return changed;\n        }\n        await outlet.componentOnReady();\n        const route = chain[index];\n        const result = await outlet.setRouteId(route.id, route.params, direction);\n        // if the outlet changed the page, reset navigation to neutral (no direction)\n        // this means nested outlets will not animate\n        if (result.changed) {\n            direction = ROUTER_INTENT_NONE;\n            changed = true;\n        }\n        // recursively set nested outlets\n        changed = await writeNavState(result.element, chain, direction, index + 1, changed);\n        // once all nested outlets are visible let's make the parent visible too,\n        // using markVisible prevents flickering\n        if (result.markVisible) {\n            await result.markVisible();\n        }\n        return changed;\n    }\n    catch (e) {\n        console.error(e);\n        return false;\n    }\n};\nconst readNavState = async (root) => {\n    const ids = [];\n    let outlet;\n    let node = root;\n    // tslint:disable-next-line:no-constant-condition\n    while (true) {\n        outlet = searchNavNode(node);\n        if (outlet) {\n            const id = await outlet.getRouteId();\n            if (id) {\n                node = id.element;\n                id.element = undefined;\n                ids.push(id);\n            }\n            else {\n                break;\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return { ids, outlet };\n};\nconst waitUntilNavNode = () => {\n    if (searchNavNode(document.body)) {\n        return Promise.resolve();\n    }\n    return new Promise(resolve => {\n        window.addEventListener('ionNavWillLoad', resolve, { once: true });\n    });\n};\nconst QUERY = ':not([no-router]) ion-nav, :not([no-router]) ion-tabs, :not([no-router]) ion-router-outlet';\nconst searchNavNode = (root) => {\n    if (!root) {\n        return undefined;\n    }\n    if (root.matches(QUERY)) {\n        return root;\n    }\n    const outlet = root.querySelector(QUERY);\n    return outlet ? outlet : undefined;\n};\n\nconst matchesRedirect = (input, route) => {\n    const { from, to } = route;\n    if (to === undefined) {\n        return false;\n    }\n    if (from.length > input.length) {\n        return false;\n    }\n    for (let i = 0; i < from.length; i++) {\n        const expected = from[i];\n        if (expected === '*') {\n            return true;\n        }\n        if (expected !== input[i]) {\n            return false;\n        }\n    }\n    return from.length === input.length;\n};\nconst routeRedirect = (path, routes) => {\n    return routes.find(route => matchesRedirect(path, route));\n};\nconst matchesIDs = (ids, chain) => {\n    const len = Math.min(ids.length, chain.length);\n    let i = 0;\n    for (; i < len; i++) {\n        if (ids[i].toLowerCase() !== chain[i].id) {\n            break;\n        }\n    }\n    return i;\n};\nconst matchesPath = (inputPath, chain) => {\n    const segments = new RouterSegments(inputPath);\n    let matchesDefault = false;\n    let allparams;\n    for (let i = 0; i < chain.length; i++) {\n        const path = chain[i].path;\n        if (path[0] === '') {\n            matchesDefault = true;\n        }\n        else {\n            for (const segment of path) {\n                const data = segments.next();\n                // data param\n                if (segment[0] === ':') {\n                    if (data === '') {\n                        return null;\n                    }\n                    allparams = allparams || [];\n                    const params = allparams[i] || (allparams[i] = {});\n                    params[segment.slice(1)] = data;\n                }\n                else if (data !== segment) {\n                    return null;\n                }\n            }\n            matchesDefault = false;\n        }\n    }\n    const matches = (matchesDefault)\n        ? matchesDefault === (segments.next() === '')\n        : true;\n    if (!matches) {\n        return null;\n    }\n    if (allparams) {\n        return chain.map((route, i) => ({\n            id: route.id,\n            path: route.path,\n            params: mergeParams(route.params, allparams[i])\n        }));\n    }\n    return chain;\n};\nconst mergeParams = (a, b) => {\n    if (!a && b) {\n        return b;\n    }\n    else if (a && !b) {\n        return a;\n    }\n    else if (a && b) {\n        return Object.assign(Object.assign({}, a), b);\n    }\n    return undefined;\n};\nconst routerIDsToChain = (ids, chains) => {\n    let match = null;\n    let maxMatches = 0;\n    const plainIDs = ids.map(i => i.id);\n    for (const chain of chains) {\n        const score = matchesIDs(plainIDs, chain);\n        if (score > maxMatches) {\n            match = chain;\n            maxMatches = score;\n        }\n    }\n    if (match) {\n        return match.map((route, i) => ({\n            id: route.id,\n            path: route.path,\n            params: mergeParams(route.params, ids[i] && ids[i].params)\n        }));\n    }\n    return null;\n};\nconst routerPathToChain = (path, chains) => {\n    let match = null;\n    let matches = 0;\n    for (const chain of chains) {\n        const matchedChain = matchesPath(path, chain);\n        if (matchedChain !== null) {\n            const score = computePriority(matchedChain);\n            if (score > matches) {\n                matches = score;\n                match = matchedChain;\n            }\n        }\n    }\n    return match;\n};\nconst computePriority = (chain) => {\n    let score = 1;\n    let level = 1;\n    for (const route of chain) {\n        for (const path of route.path) {\n            if (path[0] === ':') {\n                score += Math.pow(1, level);\n            }\n            else if (path !== '') {\n                score += Math.pow(2, level);\n            }\n            level++;\n        }\n    }\n    return score;\n};\nclass RouterSegments {\n    constructor(path) {\n        this.path = path.slice();\n    }\n    next() {\n        if (this.path.length > 0) {\n            return this.path.shift();\n        }\n        return '';\n    }\n}\n\nconst readRedirects = (root) => {\n    return Array.from(root.children)\n        .filter(el => el.tagName === 'ION-ROUTE-REDIRECT')\n        .map(el => {\n        const to = readProp(el, 'to');\n        return {\n            from: parsePath(readProp(el, 'from')),\n            to: to == null ? undefined : parsePath(to),\n        };\n    });\n};\nconst readRoutes = (root) => {\n    return flattenRouterTree(readRouteNodes(root));\n};\nconst readRouteNodes = (root, node = root) => {\n    return Array.from(node.children)\n        .filter(el => el.tagName === 'ION-ROUTE' && el.component)\n        .map(el => {\n        const component = readProp(el, 'component');\n        if (component == null) {\n            throw new Error('component missing in ion-route');\n        }\n        return {\n            path: parsePath(readProp(el, 'url')),\n            id: component.toLowerCase(),\n            params: el.componentProps,\n            children: readRouteNodes(root, el)\n        };\n    });\n};\nconst readProp = (el, prop) => {\n    if (prop in el) {\n        return el[prop];\n    }\n    if (el.hasAttribute(prop)) {\n        return el.getAttribute(prop);\n    }\n    return null;\n};\nconst flattenRouterTree = (nodes) => {\n    const routes = [];\n    for (const node of nodes) {\n        flattenNode([], routes, node);\n    }\n    return routes;\n};\nconst flattenNode = (chain, routes, node) => {\n    const s = chain.slice();\n    s.push({\n        id: node.id,\n        path: node.path,\n        params: node.params\n    });\n    if (node.children.length === 0) {\n        routes.push(s);\n        return;\n    }\n    for (const sub of node.children) {\n        flattenNode(s, routes, sub);\n    }\n};\n\nconst Router = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        this.previousPath = null;\n        this.busy = false;\n        this.state = 0;\n        this.lastState = 0;\n        /**\n         * By default `ion-router` will match the routes at the root path (\"/\").\n         * That can be changed when\n         *\n         */\n        this.root = '/';\n        /**\n         * The router can work in two \"modes\":\n         * - With hash: `/index.html#/path/to/page`\n         * - Without hash: `/path/to/page`\n         *\n         * Using one or another might depend in the requirements of your app and/or where it's deployed.\n         *\n         * Usually \"hash-less\" navigation works better for SEO and it's more user friendly too, but it might\n         * requires additional server-side configuration in order to properly work.\n         *\n         * On the otherside hash-navigation is much easier to deploy, it even works over the file protocol.\n         *\n         * By default, this property is `true`, change to `false` to allow hash-less URLs.\n         */\n        this.useHash = true;\n        this.ionRouteWillChange = createEvent(this, \"ionRouteWillChange\", 7);\n        this.ionRouteDidChange = createEvent(this, \"ionRouteDidChange\", 7);\n    }\n    async componentWillLoad() {\n        console.debug('[ion-router] router will load');\n        await waitUntilNavNode();\n        console.debug('[ion-router] found nav');\n        await this.onRoutesChanged();\n    }\n    componentDidLoad() {\n        window.addEventListener('ionRouteRedirectChanged', debounce(this.onRedirectChanged.bind(this), 10));\n        window.addEventListener('ionRouteDataChanged', debounce(this.onRoutesChanged.bind(this), 100));\n    }\n    onPopState() {\n        const direction = this.historyDirection();\n        const path = this.getPath();\n        console.debug('[ion-router] URL changed -> update nav', path, direction);\n        return this.writeNavStateRoot(path, direction);\n    }\n    onBackButton(ev) {\n        ev.detail.register(0, () => this.back());\n    }\n    /**\n     * Navigate to the specified URL.\n     *\n     * @param url The url to navigate to.\n     * @param direction The direction of the animation. Defaults to `\"forward\"`.\n     */\n    push(url, direction = 'forward') {\n        if (url.startsWith('.')) {\n            url = (new URL(url, window.location.href)).pathname;\n        }\n        console.debug('[ion-router] URL pushed -> updating nav', url, direction);\n        const path = parsePath(url);\n        this.setPath(path, direction);\n        return this.writeNavStateRoot(path, direction);\n    }\n    /**\n     * Go back to previous page in the window.history.\n     */\n    back() {\n        window.history.back();\n        return Promise.resolve(this.waitPromise);\n    }\n    /** @internal */\n    async printDebug() {\n        console.debug('CURRENT PATH', this.getPath());\n        console.debug('PREVIOUS PATH', this.previousPath);\n        printRoutes(readRoutes(this.el));\n        printRedirects(readRedirects(this.el));\n    }\n    /** @internal */\n    async navChanged(direction) {\n        if (this.busy) {\n            console.warn('[ion-router] router is busy, navChanged was cancelled');\n            return false;\n        }\n        const { ids, outlet } = await readNavState(window.document.body);\n        const routes = readRoutes(this.el);\n        const chain = routerIDsToChain(ids, routes);\n        if (!chain) {\n            console.warn('[ion-router] no matching URL for ', ids.map(i => i.id));\n            return false;\n        }\n        const path = chainToPath(chain);\n        if (!path) {\n            console.warn('[ion-router] router could not match path because some required param is missing');\n            return false;\n        }\n        console.debug('[ion-router] nav changed -> update URL', ids, path);\n        this.setPath(path, direction);\n        await this.safeWriteNavState(outlet, chain, ROUTER_INTENT_NONE, path, null, ids.length);\n        return true;\n    }\n    onRedirectChanged() {\n        const path = this.getPath();\n        if (path && routeRedirect(path, readRedirects(this.el))) {\n            this.writeNavStateRoot(path, ROUTER_INTENT_NONE);\n        }\n    }\n    onRoutesChanged() {\n        return this.writeNavStateRoot(this.getPath(), ROUTER_INTENT_NONE);\n    }\n    historyDirection() {\n        const win = window;\n        if (win.history.state === null) {\n            this.state++;\n            win.history.replaceState(this.state, win.document.title, win.document.location && win.document.location.href);\n        }\n        const state = win.history.state;\n        const lastState = this.lastState;\n        this.lastState = state;\n        if (state > lastState) {\n            return ROUTER_INTENT_FORWARD;\n        }\n        else if (state < lastState) {\n            return ROUTER_INTENT_BACK;\n        }\n        else {\n            return ROUTER_INTENT_NONE;\n        }\n    }\n    async writeNavStateRoot(path, direction) {\n        if (!path) {\n            console.error('[ion-router] URL is not part of the routing set');\n            return false;\n        }\n        // lookup redirect rule\n        const redirects = readRedirects(this.el);\n        const redirect = routeRedirect(path, redirects);\n        let redirectFrom = null;\n        if (redirect) {\n            this.setPath(redirect.to, direction);\n            redirectFrom = redirect.from;\n            path = redirect.to;\n        }\n        // lookup route chain\n        const routes = readRoutes(this.el);\n        const chain = routerPathToChain(path, routes);\n        if (!chain) {\n            console.error('[ion-router] the path does not match any route');\n            return false;\n        }\n        // write DOM give\n        return this.safeWriteNavState(document.body, chain, direction, path, redirectFrom);\n    }\n    async safeWriteNavState(node, chain, direction, path, redirectFrom, index = 0) {\n        const unlock = await this.lock();\n        let changed = false;\n        try {\n            changed = await this.writeNavState(node, chain, direction, path, redirectFrom, index);\n        }\n        catch (e) {\n            console.error(e);\n        }\n        unlock();\n        return changed;\n    }\n    async lock() {\n        const p = this.waitPromise;\n        let resolve;\n        this.waitPromise = new Promise(r => resolve = r);\n        if (p !== undefined) {\n            await p;\n        }\n        return resolve;\n    }\n    async writeNavState(node, chain, direction, path, redirectFrom, index = 0) {\n        if (this.busy) {\n            console.warn('[ion-router] router is busy, transition was cancelled');\n            return false;\n        }\n        this.busy = true;\n        // generate route event and emit will change\n        const routeEvent = this.routeChangeEvent(path, redirectFrom);\n        if (routeEvent) {\n            this.ionRouteWillChange.emit(routeEvent);\n        }\n        const changed = await writeNavState(node, chain, direction, index);\n        this.busy = false;\n        if (changed) {\n            console.debug('[ion-router] route changed', path);\n        }\n        // emit did change\n        if (routeEvent) {\n            this.ionRouteDidChange.emit(routeEvent);\n        }\n        return changed;\n    }\n    setPath(path, direction) {\n        this.state++;\n        writePath(window.history, this.root, this.useHash, path, direction, this.state);\n    }\n    getPath() {\n        return readPath(window.location, this.root, this.useHash);\n    }\n    routeChangeEvent(path, redirectFromPath) {\n        const from = this.previousPath;\n        const to = generatePath(path);\n        this.previousPath = to;\n        if (to === from) {\n            return null;\n        }\n        const redirectedFrom = redirectFromPath ? generatePath(redirectFromPath) : null;\n        return {\n            from,\n            redirectedFrom,\n            to,\n        };\n    }\n    get el() { return getElement(this); }\n};\n\nconst routerLinkCss = \":host{--background:transparent;--color:var(--ion-color-primary, #3880ff);background:var(--background);color:var(--color)}:host(.ion-color){color:var(--ion-color-base)}a{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;letter-spacing:inherit;text-decoration:inherit;text-indent:inherit;text-overflow:inherit;text-transform:inherit;text-align:inherit;white-space:inherit;color:inherit}\";\n\nconst RouterLink = class {\n    constructor(hostRef) {\n        registerInstance(this, hostRef);\n        /**\n         * When using a router, it specifies the transition direction when navigating to\n         * another page using `href`.\n         */\n        this.routerDirection = 'forward';\n        this.onClick = (ev) => {\n            openURL(this.href, ev, this.routerDirection);\n        };\n    }\n    render() {\n        const mode = getIonMode(this);\n        const attrs = {\n            href: this.href,\n            rel: this.rel,\n            target: this.target\n        };\n        return (h(Host, { onClick: this.onClick, class: Object.assign(Object.assign({}, createColorClasses(this.color)), { [mode]: true, 'ion-activatable': true }) }, h(\"a\", Object.assign({}, attrs), h(\"slot\", null))));\n    }\n};\nRouterLink.style = routerLinkCss;\n\nexport { Route as ion_route, RouteRedirect as ion_route_redirect, Router as ion_router, RouterLink as ion_router_link };\n"]}